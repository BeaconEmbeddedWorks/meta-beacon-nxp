From d2d56fdbf96ffc310d2a7133596cfc8927d41808 Mon Sep 17 00:00:00 2001
From: Adam Ford <aford173@gmail.com>
Date: Thu, 19 Dec 2019 14:17:18 -0600
Subject: [PATCH 01/21] Port LogicPD-imx8mm-kit to 4.19

Signed-off-by: Adam Ford <adam.ford@logicpd.com>
---
 .../boot/dts/freescale/logicpd-imx8mm-kit.dts |  22 +
 .../dts/freescale/lpd-imx8mm-baseboard.dtsi   | 461 +++++++++++++++++
 .../boot/dts/freescale/lpd-imx8mm-lvds.dtsi   | 145 ++++++
 .../boot/dts/freescale/lpd-imx8mm-som.dtsi    | 471 ++++++++++++++++++
 drivers/gpu/drm/bridge/Kconfig                |   2 +
 drivers/gpu/drm/bridge/Makefile               |   1 +
 drivers/gpu/drm/bridge/sn65dsi83/Kconfig      |   6 +
 drivers/gpu/drm/bridge/sn65dsi83/Makefile     |   2 +
 .../gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c  | 394 +++++++++++++++
 .../gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h  |  58 +++
 .../gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c  | 426 ++++++++++++++++
 .../drm/bridge/sn65dsi83/sn65dsi83_timing.h   |  33 ++
 12 files changed, 2021 insertions(+)
 create mode 100644 arch/arm64/boot/dts/freescale/logicpd-imx8mm-kit.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lpd-imx8mm-baseboard.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/lpd-imx8mm-lvds.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/lpd-imx8mm-som.dtsi
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/Kconfig
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/Makefile
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h

diff --git a/arch/arm64/boot/dts/freescale/logicpd-imx8mm-kit.dts b/arch/arm64/boot/dts/freescale/logicpd-imx8mm-kit.dts
new file mode 100644
index 000000000000..97ee43a41fb9
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/logicpd-imx8mm-kit.dts
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2017 NXP
+ * Copyright 2019 Logic PD, Inc
+ */
+
+/dts-v1/;
+
+#include "fsl-imx8mm.dtsi"
+#include "lpd-imx8mm-som.dtsi"
+#include "lpd-imx8mm-baseboard.dtsi"
+#include "lpd-imx8mm-lvds.dtsi"
+
+/ {
+	model = "Logic PD i.MX8M mini Developent Kit";
+	compatible = "fsl,imx8mm";
+
+	chosen {
+		bootargs = "console=ttymxc1,115200 earlycon=ec_imx6q,0x30890000,115200";
+		stdout-path = &uart2;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/lpd-imx8mm-baseboard.dtsi b/arch/arm64/boot/dts/freescale/lpd-imx8mm-baseboard.dtsi
new file mode 100644
index 000000000000..b52e85503ac1
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lpd-imx8mm-baseboard.dtsi
@@ -0,0 +1,461 @@
+
+
+/ {
+	leds {
+		compatible = "gpio-leds";
+
+		led0 {
+			label = "gen_led0";
+			gpios = <&pca6416_1 4 GPIO_ACTIVE_HIGH>;
+			default-state = "none";
+		};
+
+		led1 {
+			label = "gen_led1";
+			gpios = <&pca6416_1 5 GPIO_ACTIVE_HIGH>;
+			default-state = "none";
+		};
+
+		led2 {
+			label = "gen_led2";
+			gpios = <&pca6416_1 6 GPIO_ACTIVE_HIGH>;
+			default-state = "none";
+		};
+
+		led3 {
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_led3>;
+			label = "heartbeat";
+			gpios = <&gpio4 28 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	modem_reset: modem-reset {
+		compatible = "gpio-reset";
+		reset-gpios = <&gpio2 6 GPIO_ACTIVE_LOW>;
+		reset-delay-us = <2000>;
+		reset-post-delay-ms = <40>;
+		#reset-cells = <0>;
+	};
+
+	reg_pcie_pwr_en: regulator-pci_pwr_en {
+		compatible = "regulator-fixed";
+		regulator-name = "pci_pwr_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpio = <&pca6416_1 1 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&reg_pcie_nclkreq>;
+		startup-delay-us = <5000000>;
+	};
+
+	reg_pcie_nclkreq: regulator-pcie_nclkreq {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie_nclkreq";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&pca6416_1 2 GPIO_ACTIVE_LOW>;
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		startup-delay-us = <100>;
+		off-on-delay-us = <12000>;
+	};
+
+	reg_usb_otg_vbus: usb_otg_vbus {
+		compatible = "regulator-fixed";
+		pinctrl-0 = <&pinctrl_reg_usb_otg>;
+		regulator-name = "usb_otg_vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio4 29 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_usb_h1_vbus: regulator-usbh1vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb_h1_vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&pca6416_1 7 GPIO_ACTIVE_LOW>; /* nRST */
+		enable-active-low;
+	};
+
+	reg_audio: regulator-audio {
+		compatible = "regulator-fixed";
+		regulator-name = "3v3_aud";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&pca6416_1 11 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8962";
+		model = "wm8962-audio";
+		cpu-dai = <&sai3>;
+		audio-codec = <&wm8962>;
+		audio-routing =
+			"Headphone Jack", "HPOUTL",
+			"Headphone Jack", "HPOUTR",
+			"Ext Spk", "SPKOUTL",
+			"Ext Spk", "SPKOUTR",
+			"AMIC", "MICBIAS",
+			"IN3R", "AMIC";
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+
+	
+		pinctrl_csi_pwn: csi_pwn_grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_GPIO1_IO07_GPIO1_IO7		0x19
+			>;
+		};
+
+		pinctrl_csi_rst: csi_rst_grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_GPIO1_IO06_GPIO1_IO6		0x19
+				MX8MM_IOMUXC_GPIO1_IO14_CCMSRCGPCMIX_CLKO1	0x59
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_I2C2_SCL_I2C2_SCL			0x400001c3
+				MX8MM_IOMUXC_I2C2_SDA_I2C2_SDA			0x400001c3
+			>;
+		};
+
+		/* Added for LogicPD Phoenix SOM*/
+		pinctrl_i2c4: i2c4grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			0x400001c3
+				MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			0x400001c3
+			>;
+		};
+
+		pinctrl_espi2: espi2grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_ECSPI2_SCLK_ECSPI2_SCLK		0x82
+				MX8MM_IOMUXC_ECSPI2_MOSI_ECSPI2_MOSI		0x82
+				MX8MM_IOMUXC_ECSPI2_MISO_ECSPI2_MISO		0x82
+				MX8MM_IOMUXC_ECSPI1_SS0_GPIO5_IO9		0x41
+			>;
+		};
+
+		pinctrl_led3: led3grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_SAI3_RXFS_GPIO4_IO28	0x41
+			>;
+		};
+
+		pinctrl_pcie0: pcie0grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_GPIO1_IO05_GPIO1_IO5	0x41
+				MX8MM_IOMUXC_SAI2_RXFS_GPIO4_IO21	0x41
+			>;
+		};
+
+		pinctrl_reg_usb_otg: reg_usb_otg {
+			fsl,pins = <
+				MX8MM_IOMUXC_SAI3_RXC_GPIO4_IO29     0x19
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				MX8MM_IOMUXC_GPIO1_IO10_USB1_OTG_ID     0x41
+			>;
+		};
+
+		pinctrl_i2c4_gpio: i2c4grp-gpio {
+			fsl,pins = <
+				MX8MM_IOMUXC_I2C4_SCL_GPIO5_IO20        	0x1c3
+				MX8MM_IOMUXC_I2C4_SDA_GPIO5_IO21        	0x1c3
+			>;
+		};
+
+		pinctrl_pcal6414: pcal6414-gpio {
+			fsl,pins = <
+				MX8MM_IOMUXC_SAI2_MCLK_GPIO4_IO27        	0x19
+			>;
+		};
+
+		pinctrl_sai3: sai3grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_SAI3_TXFS_SAI3_TX_SYNC     0xd6
+				MX8MM_IOMUXC_SAI3_TXC_SAI3_TX_BCLK      0xd6
+				MX8MM_IOMUXC_SAI3_MCLK_SAI3_MCLK        0xd6
+				MX8MM_IOMUXC_SAI3_TXD_SAI3_TX_DATA0     0xd6
+				MX8MM_IOMUXC_SAI3_RXD_SAI3_RX_DATA0	0xd6
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_UART2_RXD_UART2_DCE_RX	0x140
+				MX8MM_IOMUXC_UART2_TXD_UART2_DCE_TX	0x140
+			>;
+		};
+
+		pinctrl_uart3: uart3grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_ECSPI1_SCLK_UART3_DCE_RX		0x140
+				MX8MM_IOMUXC_ECSPI1_MOSI_UART3_DCE_TX		0x140
+			>;
+		};
+
+		pinctrl_usdhc2_gpio: usdhc2grpgpio {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD2_CD_B_USDHC2_CD_B	0x41
+				MX8MM_IOMUXC_SD2_RESET_B_GPIO2_IO19	0x41
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK		0x190
+				MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d0
+				MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d0
+				MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d0
+				MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d0
+				MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d0
+				MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x1d0
+			>;
+		};
+
+		pinctrl_usdhc2_100mhz: usdhc2grp100mhz {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK		0x194
+				MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d4
+				MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d4
+				MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d4
+				MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d4
+				MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d4
+				MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x1d0
+			>;
+		};
+
+		pinctrl_usdhc2_200mhz: usdhc2grp200mhz {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK		0x196
+				MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d6
+				MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d6
+				MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d6
+				MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d6
+				MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d6
+				MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x1d0
+			>;
+		};
+};
+
+&csi1_bridge {
+	fsl,mipi-mode;
+	status = "okay";
+	port {
+		csi1_ep: endpoint {
+			remote-endpoint = <&csi1_mipi_ep>;
+		};
+	};
+};
+
+&ecspi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_espi2>;
+	status = "okay";
+	cs-gpios = <&gpio5 9 0>;
+
+	at25@0 {
+		compatible = "atmel,at25";
+		reg = <0>;
+		spi-max-frequency = <5000000>;
+		spi-cpha;
+		spi-cpol;
+
+		pagesize = <32>;
+		size = <2048>;
+		address-width = <16>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	ov5640_mipi: ov5640_mipi@10 {
+		compatible = "ovti,ov5640_mipi";
+		reg = <0x10>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_pwn>, <&pinctrl_csi_rst>;
+		clocks = <&clk IMX8MM_CLK_CLKO1>;
+		clock-names = "csi_mclk";
+		assigned-clocks = <&clk IMX8MM_CLK_CLKO1>;
+		assigned-clock-parents = <&clk IMX8MM_CLK_24M>;
+		assigned-clock-rates = <0>, <24000000>;
+		csi_id = <0>;
+		pwn-gpios = <&gpio1 7 GPIO_ACTIVE_HIGH>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		port {
+			ov5640_mipi1_ep: endpoint {
+				remote-endpoint = <&mipi1_sensor_ep>;
+			};
+		};
+	};
+
+};
+
+&mipi_csi_1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	port {
+		mipi1_sensor_ep: endpoint1 {
+			remote-endpoint = <&ov5640_mipi1_ep>;
+			data-lanes = <2>;
+			csis-hs-settle = <13>;
+			csis-clk-settle = <2>;
+			csis-wclk;
+		};
+
+		csi1_mipi_ep: endpoint2 {
+			remote-endpoint = <&csi1_ep>;
+		};
+	};
+};
+
+&i2c4 {
+
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	pinctrl-1 = <&pinctrl_i2c4_gpio>;
+	scl-gpios = <&gpio5 20 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio5 21 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	pca6416_0: gpio@20 {
+		compatible = "ti,tca6416";
+		reg = <0x20>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_pcal6414>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <27 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	pca6416_1: gpio@21 {
+		compatible = "ti,tca6416";
+		reg = <0x21>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <27 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	wm8962: audio-codec@1a {
+		compatible = "wlf,wm8962";
+		reg = <0x1a>;
+		clocks = <&clk IMX8MM_CLK_SAI3_ROOT>;
+		clock-names = "xclk";
+		DCVDD-supply = <&reg_audio>;
+		DBVDD-supply = <&reg_audio>;
+		AVDD-supply = <&reg_audio>;
+		CPVDD-supply = <&reg_audio>;
+		MICVDD-supply = <&reg_audio>;
+		PLLVDD-supply = <&reg_audio>;
+		SPKVDD1-supply = <&reg_audio>;
+		SPKVDD2-supply = <&reg_audio>;
+		gpio-cfg = <
+			0x0000 /* 0:Default */
+			0x0000 /* 1:Default */
+			0x0000 /* 2:FN_DMICCLK */
+			0x0000 /* 3:Default */
+			0x0000 /* 4:FN_DMICCDAT */
+			0x0000 /* 5:Default */
+		>;
+	};
+};
+
+&clk {
+	assigned-clocks = <&clk IMX8MM_AUDIO_PLL1>, <&clk IMX8MM_AUDIO_PLL2>;
+	assigned-clock-rates = <393216000>, <361267200>;
+};
+
+&pcie0{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie0>;
+	vpcie-supply = <&reg_pcie_pwr_en>;
+	disable-gpio = <&gpio1 5 GPIO_ACTIVE_LOW>;
+	reset-gpio = <&gpio4 21 GPIO_ACTIVE_LOW>;
+	ext_osc = <1>;
+	status = "okay";
+};
+
+&sai3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&clk IMX8MM_CLK_SAI3>;
+	assigned-clock-parents = <&clk IMX8MM_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+&uart2 { /* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	assigned-clocks = <&clk IMX8MM_CLK_UART3>;
+	assigned-clock-parents = <&clk IMX8MM_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	dr_mode="otg";
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	pinctrl-names = "default";
+	disable-over-current;
+	dr_mode="host";
+	/*gpio = <&pca6416_1 7 0>;*/ /* nRST */
+	status = "okay";
+};
+
+/*rfee  from uboot*/
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	bus-width = <4>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/lpd-imx8mm-lvds.dtsi b/arch/arm64/boot/dts/freescale/lpd-imx8mm-lvds.dtsi
new file mode 100644
index 000000000000..d48437942c12
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lpd-imx8mm-lvds.dtsi
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2019 Logic PD, Inc
+ */
+ 
+/ {
+	backlight: backlight-lvds {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 20000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		power-supply = <&reg_lcd>;
+	};
+
+	reg_lcd: regulator-lcd {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lcd_reg>;
+		compatible = "regulator-fixed";
+		regulator-name = "lcd_panel_pwr";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio1 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		startup-delay-us = <500000>;
+		regulator-always-on;
+	};
+
+	reg_lcd_reset: regulator-lcd-reset {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lcd_rst>;
+		compatible = "regulator-fixed";
+		regulator-name = "nLCD_RESET";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio1 15 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		vin-supply = <&reg_lcd>;
+		regulator-always-on;
+	};
+};
+
+&i2c2 {
+	ili_touch: ilitouch@26 {
+		compatible = "ili,ili2117a";
+		reg = <0x26>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_touchscreen>;
+		interrupts-extended = <&gpio1 9 IRQ_TYPE_LEVEL_LOW>;
+		ili2117a,poll-period = <20>;
+		ili2117a,max-touch = <2>;
+		wakeup-source;
+	};
+
+	dsi_lvds_bridge: sn65dsi83@2d {
+		compatible = "ti,sn65dsi83";
+		reg = <0x2d>;
+		ti,dsi-lanes = <4>;
+		ti,lvds-format = <2>;
+		ti,lvds-bpp = <24>;
+		ti,width-mm = <154>;
+		ti,height-mm = <87>;
+		enable-gpios = <&gpio2 11 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds>;
+		status = "okay";
+
+		display-timings {
+			lvds {
+				clock-frequency = <30000000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <40>;
+				hfront-porch = <40>;
+				vback-porch = <29>;
+				vfront-porch = <13>;
+				hsync-len = <48>;
+				vsync-len = <3>;
+				hsync-active = <1>;
+				vsync-active = <3>;
+				de-active = <1>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		port {
+			dsi_lvds_bridge_in: endpoint {
+				remote-endpoint = <&mipi_dsi_out>;
+			};
+		};
+	};
+};
+
+&lcdif {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	port@1 {
+		mipi_dsi_out: endpoint {
+			remote-endpoint = <&dsi_lvds_bridge_in>;
+		};
+	};
+};
+
+&pwm1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+};
+
+&iomuxc {
+
+	pinctrl_lcd_reg: lcd_reggrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO08_GPIO1_IO8		0x16
+		>;
+	};
+
+	pinctrl_lcd_rst: lcd_rstgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO15_GPIO1_IO15		0x16
+		>;
+	};
+
+	pinctrl_lvds: lvdsgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD1_STROBE_GPIO2_IO11              0x16
+		>;
+	};
+
+	pinctrl_pwm1: pwm1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO01_PWM1_OUT                0x06
+		>;
+	};
+
+	pinctrl_touchscreen: touchscreengrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO09_GPIO1_IO9		0x19
+		>;
+	};
+
+};
diff --git a/arch/arm64/boot/dts/freescale/lpd-imx8mm-som.dtsi b/arch/arm64/boot/dts/freescale/lpd-imx8mm-som.dtsi
new file mode 100644
index 000000000000..894d8a82706e
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lpd-imx8mm-som.dtsi
@@ -0,0 +1,471 @@
+
+/ {
+	usdhc1_pwrseq: usdhc1_pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usdhc1_gpio>;
+		reset-gpios = <&gpio2 10 GPIO_ACTIVE_LOW>;
+		clocks = <&osc_32k>;
+		clock-names = "ext_clock";
+		post-power-on-delay-ms = <80>;
+	};
+};
+
+&A53_0 {
+	arm-supply = <&buck2_reg>;
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec1>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+			at803x,led-act-blind-workaround;
+			at803x,eee-okay;
+			at803x,vddio-1p8v;
+		};
+	};
+};
+
+&flexspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexspi0>;
+	status = "okay";
+
+	flash0: mt25qu256aba@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,mt25qu256aba";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+	};
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: bd71837@4b {
+		reg = <0x4b>;
+		compatible = "rohm,bd71840", "rohm,bd71837";
+		/* PMIC BD71837 PMIC_nINT GPIO1_IO3 */
+		pinctrl-0 = <&pinctrl_pmic>;
+		gpio_intr = <&gpio1 3 GPIO_ACTIVE_LOW>;
+
+		gpo {
+			rohm,drv = <0x0C>;	/* 0b0000_1100 all gpos with cmos output mode */
+		};
+
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			bd71837,pmic-buck2-uses-i2c-dvs;
+			bd71837,pmic-buck2-dvs-voltage = <1000000>, <900000>, <0>; /* VDD_ARM: Run-Idle */
+
+			buck1_reg: regulator@0 {
+				reg = <0>;
+				regulator-compatible = "buck1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck2_reg: regulator@1 {
+				reg = <1>;
+				regulator-compatible = "buck2";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck3_reg: regulator@2 {
+				reg = <2>;
+				regulator-compatible = "buck3";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+			};
+
+			buck4_reg: regulator@3 {
+				reg = <3>;
+				regulator-compatible = "buck4";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+			};
+
+			buck5_reg: regulator@4 {
+				reg = <4>;
+				regulator-compatible = "buck5";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6_reg: regulator@5 {
+				reg = <5>;
+				regulator-compatible = "buck6";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck7_reg: regulator@6 {
+				reg = <6>;
+				regulator-compatible = "buck7";
+				regulator-min-microvolt = <1605000>;
+				regulator-max-microvolt = <1995000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck8_reg: regulator@7 {
+				reg = <7>;
+				regulator-compatible = "buck8";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: regulator@8 {
+				reg = <8>;
+				regulator-compatible = "ldo1";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: regulator@9 {
+				reg = <9>;
+				regulator-compatible = "ldo2";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: regulator@10 {
+				reg = <10>;
+				regulator-compatible = "ldo3";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: regulator@11 {
+				reg = <11>;
+				regulator-compatible = "ldo4";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo6_reg: regulator@13 {
+				reg = <13>;
+				regulator-compatible = "ldo6";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&gpu {
+	status = "okay";
+};
+
+&i2c3 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	eeprom@50 {
+		compatible = "atmel,24c64";
+		pagesize = <32>;
+		read-only;	/* Manufacturing EEPROM programmed at factory */
+		reg = <0x50>;
+	};
+
+	rtc@51 {
+		compatible = "nxp,pcf85263";
+		reg = <0x51>;
+	};
+};
+
+&mu {
+	status = "okay";
+};
+
+&rpmsg{
+	/*
+	 * 64K for one rpmsg instance:
+	 * --0xb8000000~0xb800ffff: pingpong
+	 */
+	vdev-nums = <1>;
+	reg = <0x0 0xb8000000 0x0 0x10000>;
+	status = "okay";
+};
+
+&uart1 { /* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MM_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MM_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	resets = <&modem_reset>;
+	status = "okay";
+
+	bluetooth {
+		compatible = "brcm,bcm43438-bt";
+		shutdown-gpios = <&gpio2 6 GPIO_ACTIVE_HIGH>;
+		host-wakeup-gpios = <&gpio2 8 GPIO_ACTIVE_HIGH>;
+		device-wakeup-gpios = <&gpio2 7 GPIO_ACTIVE_HIGH>;
+		clocks = <&osc_32k>;
+		clock-names = "extclk";
+	};
+};
+
+&usdhc1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	bus-width = <4>;
+	non-removable;
+	cap-power-off-card;
+	pm-ignore-notify;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&usdhc1_pwrseq>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_wlan>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "host-wake";
+	};
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&vpu_g1 {
+	status = "okay";
+};
+
+&vpu_g2 {
+	status = "okay";
+};
+
+&vpu_h1 {
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+&iomuxc {
+
+		pinctrl_fec1: fec1grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_ENET_MDC_ENET1_MDC		0x3
+				MX8MM_IOMUXC_ENET_MDIO_ENET1_MDIO	0x3
+				MX8MM_IOMUXC_ENET_TD3_ENET1_RGMII_TD3	0x1f
+				MX8MM_IOMUXC_ENET_TD2_ENET1_RGMII_TD2	0x1f
+				MX8MM_IOMUXC_ENET_TD1_ENET1_RGMII_TD1	0x1f
+				MX8MM_IOMUXC_ENET_TD0_ENET1_RGMII_TD0	0x1f
+				MX8MM_IOMUXC_ENET_RD3_ENET1_RGMII_RD3	0x91
+				MX8MM_IOMUXC_ENET_RD2_ENET1_RGMII_RD2	0x91
+				MX8MM_IOMUXC_ENET_RD1_ENET1_RGMII_RD1	0x91
+				MX8MM_IOMUXC_ENET_RD0_ENET1_RGMII_RD0	0x91
+				MX8MM_IOMUXC_ENET_TXC_ENET1_RGMII_TXC	0x1f
+				MX8MM_IOMUXC_ENET_RXC_ENET1_RGMII_RXC	0x91
+				MX8MM_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x91
+				MX8MM_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x1f
+				MX8MM_IOMUXC_SAI2_RXC_GPIO4_IO22	0x19
+			>;
+		};
+
+		pinctrl_flexspi0: flexspi0grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_NAND_ALE_QSPI_A_SCLK		0x1c2
+				MX8MM_IOMUXC_NAND_CE0_B_QSPI_A_SS0_B		0x82
+				MX8MM_IOMUXC_NAND_DATA00_QSPI_A_DATA0		0x82
+				MX8MM_IOMUXC_NAND_DATA01_QSPI_A_DATA1		0x82
+				MX8MM_IOMUXC_NAND_DATA02_QSPI_A_DATA2		0x82
+				MX8MM_IOMUXC_NAND_DATA03_QSPI_A_DATA3		0x82
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			0x400001c3
+				MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			0x400001c3
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_I2C3_SCL_I2C3_SCL			0x400001c3
+				MX8MM_IOMUXC_I2C3_SDA_I2C3_SDA			0x400001c3
+			>;
+		};
+
+		pinctrl_pmic: pmicirq {
+			fsl,pins = <
+				MX8MM_IOMUXC_GPIO1_IO03_GPIO1_IO3		0x41
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_UART1_RXD_UART1_DCE_RX	0x140
+				MX8MM_IOMUXC_UART1_TXD_UART1_DCE_TX	0x140
+				MX8MM_IOMUXC_UART3_RXD_UART1_DCE_CTS_B	0x140
+				MX8MM_IOMUXC_UART3_TXD_UART1_DCE_RTS_B	0x140
+				MX8MM_IOMUXC_SD1_DATA4_GPIO2_IO6	0x19
+				MX8MM_IOMUXC_SD1_DATA5_GPIO2_IO7	0x19
+				MX8MM_IOMUXC_SD1_DATA6_GPIO2_IO8	0x19
+				MX8MM_IOMUXC_GPIO1_IO00_ANAMIX_REF_CLK_32K	0x141
+			>;
+		};
+
+		pinctrl_usdhc1_gpio: usdhc1grpgpio {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD1_RESET_B_GPIO2_IO10	0x41
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD1_CLK_USDHC1_CLK		0x190
+				MX8MM_IOMUXC_SD1_CMD_USDHC1_CMD		0x1d0
+				MX8MM_IOMUXC_SD1_DATA0_USDHC1_DATA0	0x1d0
+				MX8MM_IOMUXC_SD1_DATA1_USDHC1_DATA1	0x1d0
+				MX8MM_IOMUXC_SD1_DATA2_USDHC1_DATA2	0x1d0
+				MX8MM_IOMUXC_SD1_DATA3_USDHC1_DATA3	0x1d0
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp100mhz {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD1_CLK_USDHC1_CLK		0x194
+				MX8MM_IOMUXC_SD1_CMD_USDHC1_CMD		0x1d4
+				MX8MM_IOMUXC_SD1_DATA0_USDHC1_DATA0	0x1d4
+				MX8MM_IOMUXC_SD1_DATA1_USDHC1_DATA1	0x1d4
+				MX8MM_IOMUXC_SD1_DATA2_USDHC1_DATA2	0x1d4
+				MX8MM_IOMUXC_SD1_DATA3_USDHC1_DATA3	0x1d4
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp200mhz {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD1_CLK_USDHC1_CLK		0x196
+				MX8MM_IOMUXC_SD1_CMD_USDHC1_CMD		0x1d6
+				MX8MM_IOMUXC_SD1_DATA0_USDHC1_DATA0	0x1d6
+				MX8MM_IOMUXC_SD1_DATA1_USDHC1_DATA1	0x1d6
+				MX8MM_IOMUXC_SD1_DATA2_USDHC1_DATA2	0x1d6
+				MX8MM_IOMUXC_SD1_DATA3_USDHC1_DATA3	0x1d6
+			>;
+		};
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x190
+				MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d0
+				MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d0
+				MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d0
+				MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d0
+				MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d0
+				MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d0
+				MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d0
+				MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d0
+				MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d0
+				MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE 		0x190
+			>;
+		};
+
+		pinctrl_usdhc3_100mhz: usdhc3grp100mhz {
+			fsl,pins = <
+				MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x194
+				MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d4
+				MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d4
+				MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d4
+				MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d4
+				MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d4
+				MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d4
+				MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d4
+				MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d4
+				MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d4
+				MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE 		0x194
+			>;
+		};
+
+		pinctrl_usdhc3_200mhz: usdhc3grp200mhz {
+			fsl,pins = <
+				MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x196
+				MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d6
+				MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d6
+				MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d6
+				MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d6
+				MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d6
+				MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d6
+				MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d6
+				MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d6
+				MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d6
+				MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE 		0x196
+			>;
+		};
+
+		pinctrl_wdog: wdoggrp {
+			fsl,pins = <
+				MX8MM_IOMUXC_GPIO1_IO02_WDOG1_WDOG_B		0xc6
+			>;
+		};
+
+		pinctrl_wlan: wlangrp {
+			fsl,pins = <
+				MX8MM_IOMUXC_SD1_DATA7_GPIO2_IO9		0x111
+			>;
+		};
+};
+
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 365ec33621c2..352d14952fad 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -154,6 +154,8 @@ source "drivers/gpu/drm/bridge/adv7511/Kconfig"
 
 source "drivers/gpu/drm/bridge/synopsys/Kconfig"
 
+source "drivers/gpu/drm/bridge/sn65dsi83/Kconfig"
+
 config DRM_ITE_IT6263
 	tristate "ITE IT6263 LVDS/HDMI bridge"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 8af710d3f0b8..ea65cdcb67ee 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -19,3 +19,4 @@ obj-$(CONFIG_DRM_NWL_DSI) += nwl-dsi.o
 obj-$(CONFIG_DRM_SEC_MIPI_DSIM) += sec-dsim.o
 obj-$(CONFIG_DRM_ITE_IT6263) += it6263.o
 obj-$(CONFIG_DRM_NXP_SEIKO_43WVFIG) += nxp-seiko-43wvfig.o
+obj-$(CONFIG_DRM_I2C_SN65DSI83) += sn65dsi83/
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/Kconfig b/drivers/gpu/drm/bridge/sn65dsi83/Kconfig
new file mode 100644
index 000000000000..e1b8e802f61f
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/Kconfig
@@ -0,0 +1,6 @@
+config DRM_I2C_SN65DSI83
+	bool "TI SN65DSI83 MIPI DSI to LVDS bridge"
+	depends on OF
+	select DRM_MIPI_DSI
+	help
+	  TI SN65DSI83 MIPI DSI to LVDS bridge driver
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/Makefile b/drivers/gpu/drm/bridge/sn65dsi83/Makefile
new file mode 100644
index 000000000000..dee7f493b323
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/Makefile
@@ -0,0 +1,2 @@
+sn65dsi83-objs := sn65dsi83_drv.o sn65dsi83_brg.o
+obj-$(CONFIG_DRM_I2C_SN65DSI83) := sn65dsi83.o
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
new file mode 100644
index 000000000000..1cba8a5e2620
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2018 CopuLab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/slab.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_connector.h>
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include "sn65dsi83_brg.h"
+
+/* Register addresses */
+
+#define SN65DSI83_SOFT_RESET         0x09
+#define SN65DSI83_CORE_PLL           0x0A
+    #define LVDS_CLK_RANGE_SHIFT    1
+    #define HS_CLK_SRC_SHIFT        0
+
+#define SN65DSI83_PLL_DIV            0x0B
+    #define DSI_CLK_DIV_SHIFT       3
+
+#define SN65DSI83_PLL_EN             0x0D
+#define SN65DSI83_DSI_CFG            0x10
+    #define CHA_DSI_LANES_SHIFT    3
+
+#define SN65DSI83_DSI_EQ              0x11
+#define SN65DSI83_CHA_DSI_CLK_RNG     0x12
+#define SN65DSI83_CHB_DSI_CLK_RNG     0x13
+#define SN65DSI83_LVDS_MODE           0x18
+    #define DE_NEG_POLARITY_SHIFT 7
+    #define HS_NEG_POLARITY_SHIFT 6
+    #define VS_NEG_POLARITY_SHIFT 5
+    #define LVDS_LINK_CFG_SHIFT   4
+    #define CHA_24BPP_MODE_SHIFT  3
+    #define CHA_24BPP_FMT1_SHIFT  1
+
+#define SN65DSI83_LVDS_SIGN           0x19
+#define SN65DSI83_LVDS_TERM           0x1A
+#define SN65DSI83_LVDS_CM_ADJ         0x1B
+#define SN65DSI83_CHA_LINE_LEN_LO     0x20
+#define SN65DSI83_CHA_LINE_LEN_HI     0x21
+#define SN65DSI83_CHB_LINE_LEN_LO     0x22
+#define SN65DSI83_CHB_LINE_LEN_HI     0x23
+#define SN65DSI83_CHA_VERT_LINES_LO   0x24
+#define SN65DSI83_CHA_VERT_LINES_HI   0x25
+#define SN65DSI83_CHB_VERT_LINES_LO   0x26
+#define SN65DSI83_CHB_VERT_LINES_HI   0x27
+#define SN65DSI83_CHA_SYNC_DELAY_LO   0x28
+#define SN65DSI83_CHA_SYNC_DELAY_HI   0x29
+#define SN65DSI83_CHB_SYNC_DELAY_LO   0x2A
+#define SN65DSI83_CHB_SYNC_DELAY_HI   0x2B
+#define SN65DSI83_CHA_HSYNC_WIDTH_LO  0x2C
+#define SN65DSI83_CHA_HSYNC_WIDTH_HI  0x2D
+#define SN65DSI83_CHB_HSYNC_WIDTH_LO  0x2E
+#define SN65DSI83_CHB_HSYNC_WIDTH_HI  0x2F
+#define SN65DSI83_CHA_VSYNC_WIDTH_LO  0x30
+#define SN65DSI83_CHA_VSYNC_WIDTH_HI  0x31
+#define SN65DSI83_CHB_VSYNC_WIDTH_LO  0x32
+#define SN65DSI83_CHB_VSYNC_WIDTH_HI  0x33
+#define SN65DSI83_CHA_HORZ_BACKPORCH  0x34
+#define SN65DSI83_CHB_HORZ_BACKPORCH  0x35
+#define SN65DSI83_CHA_VERT_BACKPORCH  0x36
+#define SN65DSI83_CHB_VERT_BACKPORCH  0x37
+#define SN65DSI83_CHA_HORZ_FRONTPORCH 0x38
+#define SN65DSI83_CHB_HORZ_FRONTPORCH 0x39
+#define SN65DSI83_CHA_VERT_FRONTPORCH 0x3A
+#define SN65DSI83_CHB_VERT_FRONTPORCH 0x3B
+#define SN65DSI83_CHA_ERR             0xE5
+#define SN65DSI83_TEST_PATTERN        0x3C
+#define SN65DSI83_REG_3D              0x3D
+#define SN65DSI83_REG_3E              0x3E
+
+static int sn65dsi83_brg_power_on(struct sn65dsi83_brg *brg)
+{
+    dev_dbg(&brg->client->dev,"%s\n",__func__);
+    gpiod_set_value_cansleep(brg->gpio_enable, 1);
+    /* Wait for 1ms for the internal voltage regulator to stabilize */
+    msleep(1);
+
+    return 0;
+}
+
+static void sn65dsi83_brg_power_off(struct sn65dsi83_brg *brg)
+{
+    dev_dbg(&brg->client->dev,"%s\n",__func__);
+    gpiod_set_value_cansleep(brg->gpio_enable, 0);
+    /*
+     * The EN pin must be held low for at least 10 ms
+     * before being asserted high
+     */
+    msleep(10);
+}
+
+static int sn65dsi83_write(struct i2c_client *client, u8 reg, u8 val)
+{
+    int ret;
+
+    ret = i2c_smbus_write_byte_data(client, reg, val);
+
+    if (ret)
+        dev_err(&client->dev, "failed to write at 0x%02x", reg);
+
+    dev_dbg(&client->dev, "%s: write reg 0x%02x data 0x%02x", __func__, reg, val);
+
+    return ret;
+}
+#define SN65DSI83_WRITE(reg,val) sn65dsi83_write(client, (reg) , (val))
+
+static int sn65dsi83_read(struct i2c_client *client, u8 reg)
+{
+    int ret;
+
+    dev_dbg(&client->dev, "client 0x%p", client);
+    ret = i2c_smbus_read_byte_data(client, reg);
+
+    if (ret < 0) {
+        dev_err(&client->dev, "failed reading at 0x%02x", reg);
+        return ret;
+    }
+
+    dev_dbg(&client->dev, "%s: read reg 0x%02x data 0x%02x", __func__, reg, ret);
+
+    return ret;
+}
+#define SN65DSI83_READ(reg) sn65dsi83_read(client, (reg))
+
+static int sn65dsi83_brg_start_stream(struct sn65dsi83_brg *brg)
+{
+    int regval;
+    struct i2c_client *client = I2C_CLIENT(brg);
+
+    dev_dbg(&client->dev,"%s\n",__func__);
+    /* Set the PLL_EN bit (CSR 0x0D.0) */
+    SN65DSI83_WRITE(SN65DSI83_PLL_EN, 0x1);
+    /* Wait for the PLL_LOCK bit to be set (CSR 0x0A.7) */
+    msleep(200);
+
+    /* Perform SW reset to apply changes */
+    SN65DSI83_WRITE(SN65DSI83_SOFT_RESET, 0x01);
+
+    /* Read CHA Error register */
+    regval = SN65DSI83_READ(SN65DSI83_CHA_ERR);
+    dev_dbg(&client->dev, "CHA (0x%02x) = 0x%02x",
+         SN65DSI83_CHA_ERR, regval);
+
+    if (!IS_ERR(brg->gpio_panel_enable))
+        gpiod_set_value_cansleep(brg->gpio_panel_enable, 1);
+
+    return 0;
+}
+
+static void sn65dsi83_brg_stop_stream(struct sn65dsi83_brg *brg)
+{
+    struct i2c_client *client = I2C_CLIENT(brg);
+    dev_dbg(&client->dev,"%s\n",__func__);
+    /* Clear the PLL_EN bit (CSR 0x0D.0) */
+    SN65DSI83_WRITE(SN65DSI83_PLL_EN, 0x00);
+
+    if (!IS_ERR(brg->gpio_panel_enable))
+        gpiod_set_value_cansleep(brg->gpio_panel_enable, 0);
+}
+
+static int sn65dsi83_calk_clk_range(int min_regval, int max_regval,
+                unsigned long min_clk, unsigned long inc,
+                unsigned long target_clk)
+{
+    int regval = min_regval;
+    unsigned long clk = min_clk;
+
+    while (regval <= max_regval) {
+        if ((clk <= target_clk) && (target_clk < (clk + inc)))
+            return regval;
+
+        regval++;
+        clk += inc;
+    }
+
+    return -1;
+}
+
+#define ABS(X) ((X) < 0 ? (-1 * (X)) : (X))
+static int sn65dsi83_calk_div(int min_regval, int max_regval, int min_div,
+                int inc, unsigned long source_clk,
+                unsigned long target_clk)
+{
+    int regval = min_regval;
+    int div = min_div;
+    unsigned long curr_delta;
+    unsigned long prev_delta = ABS(DIV_ROUND_UP(source_clk, div) -
+                    target_clk);
+
+    while (regval <= max_regval) {
+        curr_delta = ABS(DIV_ROUND_UP(source_clk, div) - target_clk);
+        if (curr_delta > prev_delta)
+            return --regval;
+
+        regval++;
+        div += inc;
+    }
+
+    return -1;
+}
+
+static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
+{
+    int regval = 0;
+    struct i2c_client *client = I2C_CLIENT(brg);
+    struct videomode *vm = VM(brg);
+
+    u32 dsi_clk = (((PIXCLK * BPP(brg)) / DSI_LANES(brg)) >> 1);
+
+    dev_info(&client->dev, "DSI clock [ %u ] Hz\n",dsi_clk);
+    dev_info(&client->dev, "Resolution [ %d x %d ] Hz\n",HACTIVE,VACTIVE);
+
+    /* Reset PLL_EN and SOFT_RESET registers */
+    SN65DSI83_WRITE(SN65DSI83_SOFT_RESET,0x00);
+    SN65DSI83_WRITE(SN65DSI83_PLL_EN,0x00);
+
+    /* LVDS clock setup */
+    if  ((25000000 <= PIXCLK) && (PIXCLK < 37500000))
+        regval = 0;
+    else
+        regval = sn65dsi83_calk_clk_range(0x01, 0x05, 37500000, 25000000,
+                    PIXCLK);
+
+    if (regval < 0) {
+        dev_err(&client->dev, "failed to configure LVDS clock");
+        return -EINVAL;
+    }
+
+    regval = (regval << LVDS_CLK_RANGE_SHIFT);
+    regval |= (1 << HS_CLK_SRC_SHIFT); /* Use DSI clock */
+    SN65DSI83_WRITE(SN65DSI83_CORE_PLL,regval);
+
+    /* DSI clock range */
+    regval = sn65dsi83_calk_clk_range(0x08, 0x64, 40000000, 5000000, dsi_clk);
+    if (regval < 0) {
+        dev_err(&client->dev, "failed to configure DSI clock range\n");
+        return -EINVAL;
+    }
+    SN65DSI83_WRITE(SN65DSI83_CHA_DSI_CLK_RNG,regval);
+
+    /* DSI clock divider */
+    regval = sn65dsi83_calk_div(0x0, 0x18, 1, 1, dsi_clk, PIXCLK);
+    if (regval < 0) {
+        dev_err(&client->dev, "failed to calculate DSI clock divider");
+        return -EINVAL;
+    }
+
+    regval = regval << DSI_CLK_DIV_SHIFT;
+    SN65DSI83_WRITE(SN65DSI83_PLL_DIV,regval);
+
+    /* Configure DSI_LANES  */
+    regval = SN65DSI83_READ(SN65DSI83_DSI_CFG);
+    regval &= ~(3 << CHA_DSI_LANES_SHIFT);
+    regval |= ((4 - DSI_LANES(brg)) << CHA_DSI_LANES_SHIFT);
+    SN65DSI83_WRITE(SN65DSI83_DSI_CFG,regval);
+
+    /* CHA_DSI_DATA_EQ - No Equalization */
+    /* CHA_DSI_CLK_EQ  - No Equalization */
+    SN65DSI83_WRITE(SN65DSI83_DSI_EQ,0x00);
+
+    /* Video formats */
+    regval = 0;
+    if (FLAGS & DISPLAY_FLAGS_HSYNC_LOW)
+        regval |= (1 << HS_NEG_POLARITY_SHIFT);
+
+    if (FLAGS & DISPLAY_FLAGS_VSYNC_LOW)
+        regval |= (1 << VS_NEG_POLARITY_SHIFT);
+
+    if (brg->de_neg_polarity)
+        regval |= (1 << DE_NEG_POLARITY_SHIFT);
+
+    if (BPP(brg) == 24)
+        regval |= (1 << CHA_24BPP_MODE_SHIFT);
+
+    if (FORMAT(brg) == 1)
+        regval |= (1 << CHA_24BPP_FMT1_SHIFT);
+
+    regval |= (1 << LVDS_LINK_CFG_SHIFT);
+    SN65DSI83_WRITE(SN65DSI83_LVDS_MODE,regval);
+
+    /* Voltage and pins */
+    SN65DSI83_WRITE(SN65DSI83_LVDS_SIGN,0x00);
+    SN65DSI83_WRITE(SN65DSI83_LVDS_TERM,0x03);
+    SN65DSI83_WRITE(SN65DSI83_LVDS_CM_ADJ,0x00);
+
+    /* Configure sync delay to minimal allowed value */
+    SN65DSI83_WRITE(SN65DSI83_CHA_SYNC_DELAY_LO,0x21);
+    SN65DSI83_WRITE(SN65DSI83_CHA_SYNC_DELAY_HI,0x00);
+
+    /* Geometry */
+    SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_LO,LOW(HACTIVE));
+    SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_HI,HIGH(HACTIVE));
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_LO,LOW(VACTIVE));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_HI,HIGH(VACTIVE));
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_HSYNC_WIDTH_LO,LOW(HPW));
+    SN65DSI83_WRITE(SN65DSI83_CHA_HSYNC_WIDTH_HI,HIGH(HPW));
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_LO,LOW(VPW));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_HI,HIGH(VPW));
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_HORZ_BACKPORCH,LOW(HBP));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_BACKPORCH,LOW(VBP));
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_HORZ_FRONTPORCH,LOW(HFP));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_FRONTPORCH,LOW(VFP));
+
+    SN65DSI83_WRITE(SN65DSI83_TEST_PATTERN,0x00);
+    SN65DSI83_WRITE(SN65DSI83_REG_3D,0x00);
+    SN65DSI83_WRITE(SN65DSI83_REG_3E,0x00);
+
+    /* mute channel B */
+    SN65DSI83_WRITE(SN65DSI83_CHB_DSI_CLK_RNG, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_LO, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_HI, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_LO, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_HI, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_LO, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_HI, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_LO, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_HI, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_LO, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_HI, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_BACKPORCH, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_BACKPORCH, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_FRONTPORCH, 0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_FRONTPORCH, 0x00);
+    return 0;
+}
+
+static int sn65dsi83_brg_setup(struct sn65dsi83_brg *brg)
+{
+    struct i2c_client *client = I2C_CLIENT(brg);
+    dev_dbg(&client->dev,"%s\n",__func__);
+    sn65dsi83_brg_power_on(brg);
+    return sn65dsi83_brg_configure(brg);
+}
+
+static int sn65dsi83_brg_reset(struct sn65dsi83_brg *brg)
+{
+    /* Soft Reset reg value at power on should be 0x00 */
+    struct i2c_client *client = I2C_CLIENT(brg);
+    int ret = SN65DSI83_READ(SN65DSI83_SOFT_RESET);
+    dev_dbg(&client->dev,"%s\n",__func__);
+    if (ret != 0x00) {
+        dev_err(&client->dev,"Failed to reset the device");
+        return -ENODEV;
+    }
+    return 0;
+}
+
+static struct sn65dsi83_brg_funcs brg_func = {
+    .power_on = sn65dsi83_brg_power_on,
+    .power_off = sn65dsi83_brg_power_off,
+    .setup = sn65dsi83_brg_setup,
+    .reset = sn65dsi83_brg_reset,
+    .start_stream = sn65dsi83_brg_start_stream,
+    .stop_stream = sn65dsi83_brg_stop_stream,
+};
+
+static struct sn65dsi83_brg brg = {
+    .funcs = &brg_func,
+};
+
+struct sn65dsi83_brg *sn65dsi83_brg_get(void) {
+    return &brg;
+}
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
new file mode 100644
index 000000000000..0aceb0a16952
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
@@ -0,0 +1,58 @@
+#ifndef _SN65DSI83_BRG_H__
+#define _SN65DSI83_BRG_H__
+
+#include <linux/i2c.h>
+#include <linux/gpio/consumer.h>
+#include <video/videomode.h>
+
+struct sn65dsi83_brg;
+struct sn65dsi83_brg_funcs {
+    int (*power_on)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    void (*power_off)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    int (*reset)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    int (*setup)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    int (*start_stream)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    void (*stop_stream)(struct sn65dsi83_brg *sn65dsi8383_brg);
+};
+
+struct sn65dsi83_brg {
+    struct i2c_client *client;
+    struct gpio_desc *gpio_enable;
+    struct gpio_desc *gpio_panel_enable;
+    /* Bridge Panel Parameters */
+    struct videomode vm;
+    u32 width_mm;
+    u32 height_mm;
+    u32 format;
+    u32 bpp;
+
+    u8 num_dsi_lanes;
+    u8 burst_mode;
+    u8 de_neg_polarity;
+    struct sn65dsi83_brg_funcs *funcs;
+};
+struct sn65dsi83_brg *sn65dsi83_brg_get(void);
+
+#define I2C_DEVICE(A) &(A)->client->dev
+#define I2C_CLIENT(A) (A)->client
+#define VM(A) &(A)->vm
+#define BPP(A) (A)->bpp
+#define FORMAT(A) (A)->format
+#define DSI_LANES(A) (A)->num_dsi_lanes
+
+/* The caller has to have a vm structure defined */
+#define PIXCLK vm->pixelclock
+#define HACTIVE vm->hactive
+#define HFP vm->hfront_porch
+#define HBP vm->hback_porch
+#define HPW vm->hsync_len
+#define VACTIVE vm->vactive
+#define VFP vm->vfront_porch
+#define VBP vm->vback_porch
+#define VPW vm->vsync_len
+#define FLAGS vm->flags
+
+#define HIGH(A) (((A) >> 8) & 0xFF)
+#define LOW(A)  ((A)  & 0xFF)
+
+#endif /* _SN65DSI83_BRG_H__ */
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
new file mode 100644
index 000000000000..3239c8e0301f
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
@@ -0,0 +1,426 @@
+/*
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/slab.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_crtc_helper.h>
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include "sn65dsi83_timing.h"
+#include "sn65dsi83_brg.h"
+
+struct sn65dsi83 {
+    u8 channel_id;
+    enum drm_connector_status status;
+    bool powered;
+    struct drm_display_mode curr_mode;
+    struct drm_bridge bridge;
+    struct drm_connector connector;
+    struct device_node *host_node;
+    struct mipi_dsi_device *dsi;
+    struct sn65dsi83_brg *brg;
+};
+
+static int sn65dsi83_attach_dsi(struct sn65dsi83 *sn65dsi83);
+#define DRM_DEVICE(A) A->dev->dev
+/* Connector funcs */
+static struct sn65dsi83 *connector_to_sn65dsi83(struct drm_connector *connector)
+{
+    return container_of(connector, struct sn65dsi83, connector);
+}
+
+static int sn65dsi83_connector_get_modes(struct drm_connector *connector)
+{
+    struct sn65dsi83 *sn65dsi83 = connector_to_sn65dsi83(connector);
+    struct sn65dsi83_brg *brg = sn65dsi83->brg;
+    struct device *dev = connector->dev->dev;
+    struct drm_display_mode *mode;
+    u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+    u32 *bus_flags = &connector->display_info.bus_flags;
+    int ret;
+
+    dev_dbg(dev, "%s\n",__func__);
+    mode = drm_mode_create(connector->dev);
+    if (!mode) {
+        DRM_DEV_ERROR(dev, "Failed to create display mode!\n");
+        return 0;
+    }
+
+    drm_display_mode_from_videomode(&brg->vm, mode);
+    mode->width_mm = brg->width_mm;
+    mode->height_mm = brg->height_mm;
+    mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+
+    drm_mode_probed_add(connector, mode);
+    drm_connector_list_update(connector);
+
+    connector->display_info.width_mm = mode->width_mm;
+    connector->display_info.height_mm = mode->height_mm;
+
+    if (brg->vm.flags & DISPLAY_FLAGS_DE_HIGH)
+        *bus_flags |= DRM_BUS_FLAG_DE_HIGH;
+    if (brg->vm.flags & DISPLAY_FLAGS_DE_LOW)
+        *bus_flags |= DRM_BUS_FLAG_DE_LOW;
+    if (brg->vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
+        *bus_flags |= DRM_BUS_FLAG_PIXDATA_NEGEDGE;
+    if (brg->vm.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
+        *bus_flags |= DRM_BUS_FLAG_PIXDATA_POSEDGE;
+
+    ret = drm_display_info_set_bus_formats(&connector->display_info,
+                           &bus_format, 1);
+    if (ret)
+        return ret;
+
+    return 1;
+}
+
+static enum drm_mode_status
+sn65dsi83_connector_mode_valid(struct drm_connector *connector,
+                 struct drm_display_mode *mode)
+{
+    struct sn65dsi83 *sn65dsi83 = connector_to_sn65dsi83(connector);
+    struct device *dev = connector->dev->dev;
+	if (mode->clock > ( sn65dsi83->brg->vm.pixelclock / 1000 ))
+		return MODE_CLOCK_HIGH;
+
+    dev_dbg(dev, "%s: mode: %d*%d@%d is valid\n",__func__,
+            mode->hdisplay,mode->vdisplay,mode->clock);
+    return MODE_OK;
+}
+
+static struct drm_connector_helper_funcs sn65dsi83_connector_helper_funcs = {
+    .get_modes = sn65dsi83_connector_get_modes,
+    .mode_valid = sn65dsi83_connector_mode_valid,
+};
+
+static enum drm_connector_status
+sn65dsi83_connector_detect(struct drm_connector *connector, bool force)
+{
+    struct sn65dsi83 *sn65dsi83 = connector_to_sn65dsi83(connector);
+    struct device *dev = connector->dev->dev;
+    enum drm_connector_status status;
+    dev_dbg(dev, "%s\n",__func__);
+
+    status = connector_status_connected;
+    sn65dsi83->status = status;
+    return status;
+}
+
+int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
+                        uint32_t maxX, uint32_t maxY);
+
+static struct drm_connector_funcs sn65dsi83_connector_funcs = {
+    .dpms = drm_helper_connector_dpms,
+    .fill_modes = drm_helper_probe_single_connector_modes,
+    .detect = sn65dsi83_connector_detect,
+    .destroy = drm_connector_cleanup,
+    .reset = drm_atomic_helper_connector_reset,
+    .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+/* Bridge funcs */
+static struct sn65dsi83 *bridge_to_sn65dsi83(struct drm_bridge *bridge)
+{
+    return container_of(bridge, struct sn65dsi83, bridge);
+}
+
+static void sn65dsi83_bridge_enable(struct drm_bridge *bridge)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    dev_dbg(DRM_DEVICE(bridge),"%s\n",__func__);
+    sn65dsi83->brg->funcs->setup(sn65dsi83->brg);
+    sn65dsi83->brg->funcs->start_stream(sn65dsi83->brg);
+}
+
+static void sn65dsi83_bridge_disable(struct drm_bridge *bridge)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    dev_dbg(DRM_DEVICE(bridge),"%s\n",__func__);
+    sn65dsi83->brg->funcs->stop_stream(sn65dsi83->brg);
+    sn65dsi83->brg->funcs->power_off(sn65dsi83->brg);
+}
+
+static void sn65dsi83_bridge_mode_set(struct drm_bridge *bridge,
+                    struct drm_display_mode *mode,
+                    struct drm_display_mode *adj_mode)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    dev_dbg(DRM_DEVICE(bridge), "%s: mode: %d*%d@%d\n",__func__,
+            mode->hdisplay,mode->vdisplay,mode->clock);
+    drm_mode_copy(&sn65dsi83->curr_mode, adj_mode);
+}
+
+static int sn65dsi83_bridge_attach(struct drm_bridge *bridge)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    int ret;
+
+    dev_dbg(DRM_DEVICE(bridge),"%s\n",__func__);
+    if (!bridge->encoder) {
+        DRM_ERROR("Parent encoder object not found");
+        return -ENODEV;
+    }
+
+    sn65dsi83->connector.polled = DRM_CONNECTOR_POLL_CONNECT;
+
+    ret = drm_connector_init(bridge->dev, &sn65dsi83->connector,
+                 &sn65dsi83_connector_funcs,
+                 DRM_MODE_CONNECTOR_DSI);
+    if (ret) {
+        DRM_ERROR("Failed to initialize connector with drm\n");
+        return ret;
+    }
+    drm_connector_helper_add(&sn65dsi83->connector,
+                 &sn65dsi83_connector_helper_funcs);
+    drm_connector_attach_encoder(&sn65dsi83->connector, bridge->encoder);
+
+    ret = sn65dsi83_attach_dsi(sn65dsi83);
+
+    return ret;
+}
+
+static struct drm_bridge_funcs sn65dsi83_bridge_funcs = {
+    .enable = sn65dsi83_bridge_enable,
+    .disable = sn65dsi83_bridge_disable,
+    .mode_set = sn65dsi83_bridge_mode_set,
+    .attach = sn65dsi83_bridge_attach,
+};
+
+static int sn65dsi83_parse_dt(struct device_node *np,
+    struct sn65dsi83 *sn65dsi83)
+{
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    u32 num_lanes = 2, bpp = 24, format = 2, width = 149, height = 93;
+    u8 burst_mode = 0;
+    u8 de_neg_polarity = 0;
+    struct device_node *endpoint;
+
+    endpoint = of_graph_get_next_endpoint(np, NULL);
+    if (!endpoint)
+        return -ENODEV;
+
+    sn65dsi83->host_node = of_graph_get_remote_port_parent(endpoint);
+    if (!sn65dsi83->host_node) {
+        of_node_put(endpoint);
+        return -ENODEV;
+    }
+
+    of_property_read_u32(np, "ti,dsi-lanes", &num_lanes);
+    of_property_read_u32(np, "ti,lvds-format", &format);
+    of_property_read_u32(np, "ti,lvds-bpp", &bpp);
+    of_property_read_u32(np, "ti,width-mm", &width);
+    of_property_read_u32(np, "ti,height-mm", &height);
+    burst_mode = of_property_read_bool(np, "ti,burst-mode");
+    de_neg_polarity = of_property_read_bool(np, "ti,de-neg-polarity");
+
+    if (num_lanes < 1 || num_lanes > 4) {
+        dev_err(dev, "Invalid dsi-lanes: %d\n", num_lanes);
+        return -EINVAL;
+    }
+    sn65dsi83->brg->num_dsi_lanes = num_lanes;
+    sn65dsi83->brg->burst_mode = burst_mode;
+    sn65dsi83->brg->de_neg_polarity = de_neg_polarity;
+
+    sn65dsi83->brg->gpio_enable = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+    if (IS_ERR(sn65dsi83->brg->gpio_enable)) {
+        dev_err(dev, "failed to parse enable gpio");
+        return PTR_ERR(sn65dsi83->brg->gpio_enable);
+    }
+
+    sn65dsi83->brg->gpio_panel_enable = devm_gpiod_get(dev, "enable-panel", GPIOD_OUT_LOW);
+    if (!IS_ERR(sn65dsi83->brg->gpio_panel_enable)) {
+        gpiod_set_value_cansleep(sn65dsi83->brg->gpio_panel_enable, 0);
+        msleep(200);
+    } else
+        dev_warn(dev, "failed to parse enable panel gpio");
+
+    sn65dsi83->brg->format = format;
+    sn65dsi83->brg->bpp = bpp;
+
+    sn65dsi83->brg->width_mm = width;
+    sn65dsi83->brg->height_mm = height;
+
+    /* Read default timing if there is not device tree node for */
+    if ((of_get_videomode(np, &sn65dsi83->brg->vm, 0)) < 0)
+        videomode_from_timing(&panel_default_timing, &sn65dsi83->brg->vm);
+
+    of_node_put(endpoint);
+    of_node_put(sn65dsi83->host_node);
+
+    return 0;
+}
+
+static int sn65dsi83_probe(struct i2c_client *i2c,
+    const struct i2c_device_id *id)
+{
+    struct sn65dsi83 *sn65dsi83;
+    struct device *dev = &i2c->dev;
+    int ret;
+
+    dev_dbg(dev,"%s\n",__func__);
+    if (!dev->of_node)
+        return -EINVAL;
+
+    sn65dsi83 = devm_kzalloc(dev, sizeof(*sn65dsi83), GFP_KERNEL);
+    if (!sn65dsi83)
+        return -ENOMEM;
+
+    /* Initialize it before DT parser */
+    sn65dsi83->brg = sn65dsi83_brg_get();
+    sn65dsi83->brg->client = i2c;
+
+    sn65dsi83->powered = false;
+    sn65dsi83->status = connector_status_disconnected;
+
+    i2c_set_clientdata(i2c, sn65dsi83);
+
+    ret = sn65dsi83_parse_dt(dev->of_node, sn65dsi83);
+    if (ret)
+        return ret;
+
+    sn65dsi83->brg->funcs->power_off(sn65dsi83->brg);
+    sn65dsi83->brg->funcs->power_on(sn65dsi83->brg);
+    ret  = sn65dsi83->brg->funcs->reset(sn65dsi83->brg);
+    if (ret != 0x00) {
+        dev_err(dev, "Failed to reset the device");
+        return -ENODEV;
+    }
+    sn65dsi83->brg->funcs->power_off(sn65dsi83->brg);
+
+
+    sn65dsi83->bridge.funcs = &sn65dsi83_bridge_funcs;
+    sn65dsi83->bridge.of_node = dev->of_node;
+
+    drm_bridge_add(&sn65dsi83->bridge);
+    
+
+    return 0;
+}
+
+static int sn65dsi83_attach_dsi(struct sn65dsi83 *sn65dsi83)
+{
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    struct mipi_dsi_host *host;
+    struct mipi_dsi_device *dsi;
+    int ret = 0;
+    const struct mipi_dsi_device_info info = { .type = "sn65dsi83",
+                           .channel = 0,
+                           .node = NULL,
+                         };
+
+    dev_dbg(dev, "%s\n",__func__);
+    host = of_find_mipi_dsi_host_by_node(sn65dsi83->host_node);
+    if (!host) {
+        dev_err(dev, "failed to find dsi host\n");
+        return -EPROBE_DEFER;
+    }
+
+    dsi = mipi_dsi_device_register_full(host, &info);
+    if (IS_ERR(dsi)) {
+        dev_err(dev, "failed to create dsi device\n");
+        ret = PTR_ERR(dsi);
+        return -ENODEV;
+    }
+
+    sn65dsi83->dsi = dsi;
+
+    dsi->lanes = sn65dsi83->brg->num_dsi_lanes;
+    dsi->format = MIPI_DSI_FMT_RGB888;
+    dsi->mode_flags = MIPI_DSI_MODE_VIDEO;
+    if (sn65dsi83->brg->burst_mode)
+        dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST;
+    else
+        dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+
+    ret = mipi_dsi_attach(dsi);
+    if (ret < 0) {
+        dev_err(dev, "failed to attach dsi to host\n");
+        mipi_dsi_device_unregister(dsi);
+    }
+
+    return ret;
+}
+
+static void sn65dsi83_detach_dsi(struct sn65dsi83 *sn65dsi83)
+{
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    dev_dbg(dev, "%s\n",__func__);
+    mipi_dsi_detach(sn65dsi83->dsi);
+    mipi_dsi_device_unregister(sn65dsi83->dsi);
+}
+
+static int sn65dsi83_remove(struct i2c_client *i2c)
+{
+    struct sn65dsi83 *sn65dsi83 = i2c_get_clientdata(i2c);
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    dev_dbg(dev, "%s\n",__func__);
+
+    sn65dsi83_detach_dsi(sn65dsi83);
+    drm_bridge_remove(&sn65dsi83->bridge);
+
+    return 0;
+}
+
+static const struct i2c_device_id sn65dsi83_i2c_ids[] = {
+    { "sn65dsi83", 0 },
+    { }
+};
+MODULE_DEVICE_TABLE(i2c, sn65dsi83_i2c_ids);
+
+static const struct of_device_id sn65dsi83_of_ids[] = {
+    { .compatible = "ti,sn65dsi83" },
+    { }
+};
+MODULE_DEVICE_TABLE(of, sn65dsi83_of_ids);
+
+static struct mipi_dsi_driver sn65dsi83_dsi_driver = {
+    .driver.name = "sn65dsi83",
+};
+
+static struct i2c_driver sn65dsi83_driver = {
+    .driver = {
+        .name = "sn65dsi83",
+        .of_match_table = sn65dsi83_of_ids,
+    },
+    .id_table = sn65dsi83_i2c_ids,
+    .probe = sn65dsi83_probe,
+    .remove = sn65dsi83_remove,
+};
+
+static int __init sn65dsi83_init(void)
+{
+    if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+        mipi_dsi_driver_register(&sn65dsi83_dsi_driver);
+
+    return i2c_add_driver(&sn65dsi83_driver);
+}
+module_init(sn65dsi83_init);
+
+static void __exit sn65dsi83_exit(void)
+{
+    i2c_del_driver(&sn65dsi83_driver);
+
+    if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+        mipi_dsi_driver_unregister(&sn65dsi83_dsi_driver);
+}
+module_exit(sn65dsi83_exit);
+
+MODULE_AUTHOR("CompuLab <compulab@compula.co.il>");
+MODULE_DESCRIPTION("SN65DSI bridge driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h
new file mode 100644
index 000000000000..e9bb6633c376
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h
@@ -0,0 +1,33 @@
+#ifndef __SN65DSI83_TIMING_H__
+#define __SN65DSI83_TIMING_H__
+
+/* Default Video Parameters */
+#define PIXCLK_INIT 62500000
+
+#define HACTIVE_INIT 1280
+#define HPW_INIT 2
+#define HBP_INIT 6
+#define HFP_INIT 5
+
+#define VACTIVE_INIT 800
+#define VPW_INIT 1
+#define VBP_INIT 2
+#define VFP_INIT 3
+
+static const struct display_timing panel_default_timing = {
+    .pixelclock = { PIXCLK_INIT, PIXCLK_INIT, PIXCLK_INIT },
+    .hactive = { HACTIVE_INIT, HACTIVE_INIT, HACTIVE_INIT },
+    .hfront_porch = { HFP_INIT, HFP_INIT, HFP_INIT },
+    .hsync_len = { HPW_INIT, HPW_INIT, HPW_INIT },
+    .hback_porch = { HBP_INIT, HBP_INIT, HBP_INIT },
+    .vactive = { VACTIVE_INIT, VACTIVE_INIT, VACTIVE_INIT },
+    .vfront_porch = { VFP_INIT, VFP_INIT, VFP_INIT },
+    .vsync_len = { VPW_INIT, VPW_INIT, VPW_INIT },
+    .vback_porch = { VBP_INIT, VBP_INIT, VBP_INIT },
+    .flags = DISPLAY_FLAGS_HSYNC_LOW |
+         DISPLAY_FLAGS_VSYNC_LOW |
+         DISPLAY_FLAGS_DE_LOW |
+         DISPLAY_FLAGS_PIXDATA_NEGEDGE,
+};
+
+#endif /* __SN65DSI83_TIMING_H__ */
-- 
2.17.1

